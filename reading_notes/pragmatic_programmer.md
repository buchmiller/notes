# The Pragmatic Programmer

These are my personal reading notes and are mostly written in my own words. Please reference the book for the original text as intended by the authors.

## Chapter 1 - A Pragmatic Philosophy

Being a pragmatic programmer is about your attitude and how you approach various problems.

- Take responsibility. Acknowledge failures and shortcomings. Provide multiple options for how to resolve an issue.
- Software gets worse over time when left unmaintained. Leave the code better than you found it. Use common sense for how much time to spend.
- To help bring about change, actually do/build something - even just part of it. Make sure to do so gradually so it doesn't get rejected.
- Users should be involved in deciding what functionality is good enough. Share the trade-offs with them - the project can be done sooner if some errors are acceptable.
- Constantly build up and invest in your learning. The industry can change quickly, and our knowledge needs to stay relevant.
- Understand the audience when choosing when and how to communicate something with them.

## Chapter 2 - A Pragmatic Approach

Some practices and approaches will help you develop better code.

- Reduce duplication when possible. Limit documentation to only live where it is most relevant. Share common code in an easily accessible manner.
- Keep things decoupled and independent. Keeping layers of a system in separate modules enables easily changing just one part.
- When making a decision, don't get locked into a certain way of doing it. Plan ahead so that parts can easily be removed or changed later.
- Use tracer bullets to test that all parts of system work together. Create minimal project that utilizes all parts of the system. This project is kept and added onto.
- Use prototype to learn / answer specific question / test ideas. Throw away after.
- When applicable, offer a higher-level language to abstract away unimportant details.

## Chapter 3 - The Basic Tools
